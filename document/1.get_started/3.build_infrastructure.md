# Infrastructureをビルドする
Terraformをインストールして、インフラを作り始めてみよう。

私たちは有名でよく使われるAWSのインフラ構築でガイドをスタートする。
しかし、AWSだけでなくTerraformは一つの構成管理で多くのプラットフォームに対応している。
いくつかの例は、ユースケースの章に記載されている。

もし、あなたがAWSのアカウントを持っていなければ、今一つ用意してください。
このガイドにおいてAWSの無料トライアルの期間内で収まるリソースのみを使い無料で行える予定です。
もし、既にアカウントを持っている場合でも、多くとも数ドル以下の使用量で収まる予定です。

  警告！もし無料期間のアカウントを使用しなければ、あたなはこれらの例を起動するのにお金がかかるかもしれません。
  ほとんどのものは数ドル程度ですが、Terraformでは被りません。

## 構成
Terraformではインフラを記述するのに使われるファイルのセットは、
Terraform configurationとして知られている。

構成ファイルのフォーマットはここに記載されている。
構成ファイルはJSON形式も使用でき流が、マシンにより出力されるJSONのみを使用することを推奨する。

全体の構成を以下に記載する。
個々の詳細は後ほど調べます。
`example.tf`という名前でコンテンツを保存する。
Terraformは全てのファイルを読み込むため、他に別の`.tf`という拡張子のファイルがディレクトリが無いことを確認してください。

```
provider "aws" {
  profile    = "default"
  region     = "us-east-1"
}

resource "aws_instance" "example" {
  ami           = "ami-2757f631"
  instance_type = "t2.micro"
}
```

  注意: この上記の構成はほとんどのEC2アカウントで動くように意図されており、defaultのVPCにアクセスする。
  元々EC2を使用しているユーザのための情報として、EC2 `ami-408c7f28`というAMIでt1.microのインスタンスを
  us-east-1で作成している。もし、他のリージョンを使いたいなら、regionとAMIを選ぶ必要がある。


ここで設定されたAWSプロファイルはMacOSもしくはLinuxでは以下`~/.aws/credentials`、Windowsでは`%UserProfile%\.aws\credentials`の設定ファイルを呼ぶ。
HashiCorpは*.tfファイルに認証情報をハードコードしない方法を強く推奨する。
私たちは明示的にAWSの設定プロファイルをTerraformが機密性の高い認証情報にアクセスするかを説明する。

AWSのプロフィールを確認し、Terraformに正しくプラットフォームの認証情報が渡されているか確認するために、
AWSのCLIをインストールして、`aws configure`のコマンドを実施してください。
AWS CLIはコマンドラインでの確認を行いあなたのAWSAccess Key ID, Secret Access Keyを保存する。
それらの認証情報はこのページで見つけることができる。

  注意: もしあなたが単にAWS認証情報を除外したいなら、Terraformは保存されたAWSのAPIもしくはIAMインスタンスのプロファイルの認証情報を自動的に探す。
  この選択肢はよりいくつかの状況を簡潔にする。いくつかの状況とは、tfファイルはソースコードの修正からの確認されるか、
  １人以上の管理者ユーザーがいるような状況である。
  この章の詳細を見てください。IAMの認証をTerraformの設定から消すことであなたはソースコントロールできなくしたり、AWSのCLI認証情報を変更することなく異なるIAM認証情報に紐付けることもできる。

この章で述べる例はTerraformがデプロイ適用する準備ができている状態で、
一般的な構造は直感的で分かりやすいものである。

### Providers
providerのブロックはプロバイダー設定するために使われ、
この例では、AWSで、providerはリソースの作成と管理の責務を持っている。
TerraformがサービスのAPIを呼び出しに変換するプラグインがプロバイダである。
プロバイダはAPIとの相互通信の理解とリソースを出力する責務を持つ。
TerraformがどのようなAPIとの変換が行えるため、ほとんどどのインフラにおいてもTerraformのリソースで表現できる。

複数のproviderブロックは、もしTerraformの構成管理で複数の異なるプロバイダリソースを管理するのであれば存在し得る。
複数のプロバイダを設定の中に追加するために、その複数のproviderを宣言し、リソースをそれらのプロバイダと紐付ける。


Multiple provider blocks can exist if a Terraform configuration manages resources from different providers. To add multiple providers in your configuration, declare the providers and create resources associated with those providers. If your configuration creates a new AWS instance in your environment and you need to add that instance to your Datadog monitoring, you would declare the providers sequentially and then declare your resources for each. In the example below, using multiple providers enables us to pass the instance information directly into the monitoring query.

```
provider "aws" {
  profile    = "default"
  region     = "us-east-1"
}

provider "datadog" {
  api_key = var.datadog_api_key
  app_key = var.datadog_app_key
}

# Create a new AWS Instance
resource "aws_instance" "example" {
  ami           = "ami-2757f631"
  instance_type = "t2.micro"
}

# Create a new Datadog monitor
resource "datadog_monitor" "example" {
  name               = "Instance Example"
  type               = "metric alert"
  message            = "Monitor triggered. Notify: @hipchat-channel"
  escalation_message = "Escalation message @pagerduty"

  query = "avg(last_1h):avg:aws.ec2.cpu{host:${aws_instance.example.id}} by {host} > 4"

  thresholds = {
    ok                = 0
    warning           = 2
    warning_recovery  = 1
    critical          = 4
    critical_recovery = 3
  }

  notify_no_data    = false
  renotify_interval = 60

  notify_audit = false
  timeout_h    = 60
  include_tags = true

  silenced = {
    "*" = 0
  }
}
```

### Resources
The resource block defines a resource that exists within the infrastructure. A resource might be a physical component such as an EC2 instance, or it can be a logical resource such as a Heroku application.

The resource block has two strings before opening the block: the resource type and the resource name. In our example, the resource type is "aws_instance" and the name is "example." The prefix of the type maps to the provider. In our case "aws_instance" automatically tells Terraform that it is managed by the "aws" provider.

Within the resource block itself is configuration for that resource. This is dependent on each resource provider and is fully documented within our providers reference. For our EC2 instance, we specify an AMI for Ubuntu, and request a "t2.micro" instance so we qualify under the free tier.

## Initialization
The first command to run for a new configuration -- or after checking out an existing configuration from version control -- is terraform init, which initializes various local settings and data that will be used by subsequent commands.

Terraform uses a plugin based architecture to support the numerous infrastructure and service providers available. As of Terraform version 0.10.0, each "Provider" is its own encapsulated binary distributed separately 
```
$ terraform init
Initializing the backend...

Initializing provider plugins...
- Checking for available provider plugins...
- Downloading plugin for provider "aws" (terraform-providers/aws) 2.10.0...

The following providers do not have any version constraints in configuration,
so the latest version was installed.

To prevent automatic upgrades to new major versions that may contain breaking
changes, it is recommended to add version = "..." constraints to the
corresponding provider blocks in configuration, with the constraint strings
suggested below.

* provider.aws: version = "~> 2.10"

Terraform has been successfully initialized!

You may now begin working with Terraform. Try running "terraform plan" to see
any changes that are required for your infrastructure. All Terraform commands
should now work.

If you ever set or change modules or backend configuration for Terraform,
rerun this command to reinitialize your working directory. If you forget, other
commands will detect it and remind you to do so if necessary.
```
The aws provider plugin is downloaded and installed in a subdirectory of the current working directory, along with various other book-keeping files.

The output specifies which version of the plugin was installed, and suggests specifying that version in configuration to ensure that running terraform init in future will install a compatible version. This step is not necessary for following the getting started guide, since this configuration will be discarded at the end.

## Formatting and Validating Configurations
To follow style conventions, we recommend language consistency between files and modules written by different teams. The terraform fmt command enables standardization which automatically updates configurations in the current directory for easy readability and consistency.

If you are copying configuration snippets or just want to make sure your configuration is syntactically valid and internally consistent, the built in terraform validate command will check and report errors within modules, attribute names, and value types.

## Apply Changes

    Note: The commands shown in this guide apply to Terraform 0.11 and above. Earlier versions require using the terraform plan command to see the execution plan before applying it. Use terraform version to confirm your running version.

In the same directory as the example.tf file you created, run terraform apply. You should see output similar to below, though we've truncated some of the output to save space:

