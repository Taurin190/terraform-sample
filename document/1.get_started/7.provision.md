# Provision
あなたは既にインフラを作成し修正できます。
それでは、provisionersを使って作成時にどのようにインスタンス初期化するかを見ていきましょう。

もし、Packerのようなイメージベースのインフラを使用しているなら、
あなたが学んできたことで十分であるはずだ。
しかし、もしあなたがインスタンスに最初のセットアップを必要とするなら、
provisionersであなたはファイルのアップロード、シェルスクリプトの起動、
インストールしてソフトウェアの起動などを行えます。

## Prerequisites
このトラックでは、以前の章のガイドを読み終えた上で進めてください。
そして、次のような設定でガイドをスタートします。

`learn-terraform-aws-instance`というディレクトリを作成し、
`example.tf`という名前のファイルにコードを貼り付けてください。

```
provider "aws" {
  profile    = "default"
  region     = "us-east-1"
}

resource "aws_instance" "example" {
  ami           = "ami-b374d5a5"
  instance_type = "t2.micro"
}
```

## Defining a Provisioner
provisionerを定義するため、"example"と定義されたEC2インスタンスのリソースブロックを
次のように修正してください。

```
resource "aws_instance" "example" {
  ami           = "ami-b374d5a5"
  instance_type = "t2.micro"

  provisioner "local-exec" {
    command = "echo ${aws_instance.example.public_ip} > ip_address.txt"
  }
}
```

This adds a `provisioner` block within the `resource` block. Multiple `provisioner` blocks can be added to define multiple provisioning steps. Terraform supports multiple provisioners, but for this example we are using the `local-exec` provisioner.

Run `terraform init` and `terraform apply` and observe the `local-exec` provisioner executing a command locally on your machine running Terraform. We're using this provisioner versus the others so we don't have to worry about specifying any connection info right now. The `local-exec` provisioner you just ran created a file called `ip_address.txt` on your local machine where you ran your terraform apply command.

```
$ cat ip_address.txt
54.89.98.96
```

Another useful provisioner is remote-exec which invokes a script on a remote resource after it is created. This can be used to run a configuration management tool, bootstrap into a cluster, etc. In order to use a remote-exec provisioner, you must choose an ssh or winrm connection in the form of a connection block within the provisioner. Here is an example of how to use remote-exec to install a specific package on a single instance at startup. You should have an ssh key created with appropriate permissions to run the example below.

Create an ssh key with no passphrase with ssh-keygen -t rsa and use the name terraform. Update the permissions of that key with chmod 400 ~/.ssh/terraform.


    This example is for reference and should not be used without testing. If you are running this, create a new Terraform project folder for this example.


```
provider "aws" {
  profile = "default"
  region  = "us-west-2"
}

resource "aws_key_pair" "example" {
  key_name   = "examplekey"
  public_key = file("~/.ssh/terraform.pub")
}

resource "aws_instance" "example" {
  key_name      = aws_key_pair.example.key_name
  ami           = "ami-04590e7389a6e577c"
  instance_type = "t2.micro"

  connection {
    type        = "ssh"
    user        = "ec2-user"
    private_key = file("~/.ssh/terraform")
    host        = self.public_ip
  }

  provisioner "remote-exec" {
    inline = [
      "sudo amazon-linux-extras enable nginx1.12",
      "sudo yum -y install nginx",
      "sudo systemctl start nginx"
    ]
  }
}
```

This example has a few pieces to go over. The initial resource for the aws_key_pair is required for SSH connections. You must create a keypair locally to upload to AWS and the aws_key_pair resource is the function for that. The aws_instance resource needs the key_name connected to it directly as an attribute. Within the aws_instance resource, we create a connection block which must define the connection type, the user, host, and private_key attributes.

The private_key attribute is necessary to successfully provision the host. Once that connection is successful, the remote-exec provisioner will run on the remote host to install, update, and start nginx in this example.


## Running Provisioners
Provisioners are only run when a resource is created. They are not a replacement for configuration management and changing the software of an already-running server, and are instead just meant as a way to bootstrap a server. For configuration management, you should use Terraform provisioning to invoke a real configuration management solution.

Make sure that your infrastructure is destroyed if it isn't already, then run apply:

```
$ terraform apply
# ...

aws_instance.example: Creating...
  ami:           "" => "ami-b374d5a5"
  instance_type: "" => "t2.micro"
aws_eip.ip: Creating...
  instance: "" => "i-213f350a"

Apply complete! Resources: 2 added, 0 changed, 0 destroyed.
```